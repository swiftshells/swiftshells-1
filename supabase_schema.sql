-- 1. SCHEMA SETUP (Updated for Security and Atomicity)

-- Create Transactions Table (If not exists)
CREATE TABLE IF NOT EXISTS public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  type TEXT NOT NULL, -- 'Deposit', 'Refund', 'Purchase'
  amount DECIMAL NOT NULL CHECK (amount >= 0),
  description TEXT,
  trx_id TEXT UNIQUE, 
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- MIGRATION: Ensure 'status' column exists
ALTER TABLE public.transactions ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'Completed';

-- MIGRATION: Ensure 'trx_id' column exists (Fix for RPC Error: column "trx_id" does not exist)
ALTER TABLE public.transactions ADD COLUMN IF NOT EXISTS trx_id TEXT UNIQUE;

-- Create Orders Table
CREATE TABLE IF NOT EXISTS public.orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "product name" TEXT NOT NULL,
  player_id TEXT,
  amount DECIMAL NOT NULL CHECK (amount >= 0),
  email TEXT NOT NULL,
  status TEXT DEFAULT 'Processing', -- 'Pending', 'Processing', 'Completed', 'Cancelled'
  date TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create Profiles Table
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  name TEXT,
  phone TEXT,
  balance DECIMAL DEFAULT 0 CHECK (balance >= 0),
  support_pin TEXT DEFAULT '0000',
  is_verified BOOLEAN DEFAULT FALSE,
  role TEXT DEFAULT 'user',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- MIGRATION: Ensure 'role' column exists in profiles (Fix for existing tables)
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS role TEXT DEFAULT 'user';

-- 2. SECURITY DEFINER FUNCTION (Fix for RLS Recursion)
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role = 'admin'
  );
$$;

-- 3. RESET POLICIES
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
DROP POLICY IF EXISTS "Admins can view all profiles" ON public.profiles;
DROP POLICY IF EXISTS "Users can view own orders" ON public.orders;
DROP POLICY IF EXISTS "Users can view own transactions" ON public.transactions;
DROP POLICY IF EXISTS "Admins can view all orders" ON public.orders;
DROP POLICY IF EXISTS "Users and Admins view orders" ON public.orders;
DROP POLICY IF EXISTS "Admins can view all transactions" ON public.transactions;

-- 4. PERMISSIONS
GRANT ALL ON TABLE public.profiles TO authenticated;
GRANT ALL ON TABLE public.orders TO authenticated;
GRANT ALL ON TABLE public.transactions TO authenticated;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_admin TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_admin TO service_role;

-- 5. RLS POLICIES (Secure Access)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- Profiles: Users see own, Admins see all (Critical for Admin Dashboard user mapping)
CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles" ON public.profiles FOR SELECT USING (public.is_admin());

-- Order Policy: Users see own, Admins see all
CREATE POLICY "Users and Admins view orders" ON public.orders FOR SELECT USING (
  lower(auth.jwt() ->> 'email') = lower(email) 
  OR 
  public.is_admin()
);

-- Transaction Policy: Users see own, Admins see all
CREATE POLICY "Users can view own transactions" ON public.transactions FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Admins can view all transactions" ON public.transactions FOR SELECT USING (public.is_admin());

-- 6. ATOMIC FINANCIAL FUNCTIONS

-- ATOMIC ORDER PLACEMENT
CREATE OR REPLACE FUNCTION public.place_order_atomic(
  p_product_name TEXT,
  p_amount DECIMAL,
  p_player_id TEXT
) RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_user_email TEXT;
  v_current_balance DECIMAL;
BEGIN
  v_user_id := auth.uid();
  v_user_email := auth.jwt() ->> 'email';

  -- Lock profile row for update to prevent race conditions
  SELECT balance INTO v_current_balance 
  FROM public.profiles 
  WHERE id = v_user_id 
  FOR UPDATE;

  IF v_current_balance < p_amount THEN
    RETURN jsonb_build_object('success', false, 'error', 'insufficient_balance');
  END IF;

  -- 1. Deduct Balance
  UPDATE public.profiles 
  SET balance = balance - p_amount 
  WHERE id = v_user_id;

  -- 2. Create Order
  INSERT INTO public.orders ("product name", player_id, amount, email, status, date)
  VALUES (p_product_name, p_player_id, p_amount, v_user_email, 'Processing', to_char(now(), 'DD/MM/YYYY'));

  -- 3. Log Transaction
  -- Explicitly using the status column we ensured exists above
  INSERT INTO public.transactions (user_id, type, amount, description, status)
  VALUES (v_user_id, 'Purchase', p_amount, 'Purchased ' || p_product_name, 'Completed');

  RETURN jsonb_build_object('success', true);
END;
$$;

-- ATOMIC ADMIN MANAGE ORDER (CONFIRM/CANCEL)
CREATE OR REPLACE FUNCTION public.admin_manage_order(
  p_order_id BIGINT,
  p_action TEXT -- 'confirm' or 'cancel'
) RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_admin_role TEXT;
  v_order_amount DECIMAL;
  v_order_email TEXT;
  v_order_status TEXT;
  v_user_id UUID;
  v_product_name TEXT;
BEGIN
  -- 1. Verify Caller is Admin
  SELECT role INTO v_admin_role FROM public.profiles WHERE id = auth.uid();
  
  IF v_admin_role IS DISTINCT FROM 'admin' THEN
    RETURN jsonb_build_object('success', false, 'error', 'unauthorized');
  END IF;

  -- 2. Get Order Details
  SELECT amount, email, status, "product name"
  INTO v_order_amount, v_order_email, v_order_status, v_product_name
  FROM public.orders
  WHERE id = p_order_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'order_not_found');
  END IF;

  IF v_order_status = 'Completed' OR v_order_status = 'Cancelled' THEN
    RETURN jsonb_build_object('success', false, 'error', 'order_already_processed');
  END IF;

  -- Get User ID from email (approximate mapping)
  SELECT id INTO v_user_id FROM public.profiles WHERE lower(email) = lower(v_order_email) LIMIT 1;

  -- 3. Perform Action
  IF p_action = 'confirm' THEN
      UPDATE public.orders SET status = 'Completed' WHERE id = p_order_id;
      RETURN jsonb_build_object('success', true, 'status', 'Completed');

  ELSIF p_action = 'cancel' THEN
      -- Update Order
      UPDATE public.orders SET status = 'Cancelled' WHERE id = p_order_id;
      
      -- Refund Logic
      IF v_user_id IS NOT NULL THEN
        UPDATE public.profiles SET balance = balance + v_order_amount WHERE id = v_user_id;
        
        INSERT INTO public.transactions (user_id, type, amount, description, status)
        VALUES (v_user_id, 'Refund', v_order_amount, 'Refund for ' || v_product_name, 'Completed');
      END IF;

      RETURN jsonb_build_object('success', true, 'status', 'Cancelled');
  ELSE
      RETURN jsonb_build_object('success', false, 'error', 'invalid_action');
  END IF;
END;
$$;

-- ATOMIC DEPOSIT VERIFICATION
CREATE OR REPLACE FUNCTION public.verify_deposit_atomic(
  p_amount DECIMAL,
  p_trx_id TEXT,
  p_method TEXT
) RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_existing_id BIGINT;
BEGIN
  v_user_id := auth.uid();

  -- Check if TrxID already exists
  SELECT id INTO v_existing_id FROM public.transactions WHERE trx_id = p_trx_id;
  IF v_existing_id IS NOT NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'duplicate_trx_id');
  END IF;

  -- 1. Create Transaction Record
  INSERT INTO public.transactions (user_id, type, amount, trx_id, description, status)
  VALUES (v_user_id, 'Deposit', p_amount, p_trx_id, 'Manual Refill (' || p_method || ')', 'Completed');

  -- 2. Update User Balance
  UPDATE public.profiles 
  SET balance = balance + p_amount 
  WHERE id = v_user_id;

  RETURN jsonb_build_object('success', true);
END;
$$;

-- ATOMIC CANCEL & REFUND (USER SIDE)
CREATE OR REPLACE FUNCTION public.cancel_my_order(order_id_param BIGINT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_order_amount DECIMAL;
  v_user_id UUID;
  v_order_status TEXT;
  v_order_email TEXT;
  v_product_name TEXT;
  v_jwt_email TEXT;
BEGIN
  v_user_id := auth.uid();
  v_jwt_email := auth.jwt() ->> 'email';
  
  -- Find and Lock Order
  SELECT amount, status, email, "product name" 
  INTO v_order_amount, v_order_status, v_order_email, v_product_name
  FROM public.orders 
  WHERE id = order_id_param 
  FOR UPDATE;

  IF NOT FOUND OR lower(v_order_email) != lower(v_jwt_email) OR v_order_status != 'Processing' THEN
    RETURN FALSE;
  END IF;

  -- 1. Update Order Status
  UPDATE public.orders SET status = 'Cancelled' WHERE id = order_id_param;

  -- 2. Refund User Balance
  UPDATE public.profiles SET balance = COALESCE(balance, 0) + v_order_amount WHERE id = v_user_id;

  -- 3. Log Transaction
  INSERT INTO public.transactions (user_id, type, amount, description, status)
  VALUES (v_user_id, 'Refund', v_order_amount, 'Refund for ' || v_product_name, 'Completed');

  RETURN TRUE;
END;
$$;

-- CLEANUP: Remove insecure function
DROP FUNCTION IF EXISTS public.dev_only_set_admin;

-- 7. GRANT EXECUTE PERMISSIONS
GRANT EXECUTE ON FUNCTION public.place_order_atomic TO authenticated;
GRANT EXECUTE ON FUNCTION public.verify_deposit_atomic TO authenticated;
GRANT EXECUTE ON FUNCTION public.cancel_my_order TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_manage_order TO authenticated;
GRANT EXECUTE ON FUNCTION public.place_order_atomic TO service_role;
GRANT EXECUTE ON FUNCTION public.verify_deposit_atomic TO service_role;
GRANT EXECUTE ON FUNCTION public.cancel_my_order TO service_role;
GRANT EXECUTE ON FUNCTION public.admin_manage_order TO service_role;

-- 8. AUTOMATIC PROFILE CREATION & PIN GENERATION
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, balance, support_pin, role)
  VALUES (
    new.id,
    new.email,
    new.raw_user_meta_data->>'full_name',
    0,
    lpad(floor(random() * 10000)::text, 4, '0'), -- Random 4 digit pin
    'user'
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to create profile on signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- MIGRATION: Update existing profiles to have random pin if they have default '0000'
UPDATE public.profiles 
SET support_pin = lpad(floor(random() * 10000)::text, 4, '0') 
WHERE support_pin = '0000' OR support_pin IS NULL;